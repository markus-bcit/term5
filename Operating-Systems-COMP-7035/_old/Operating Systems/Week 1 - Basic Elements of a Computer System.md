# Basic Elements of a Computer System
Computer systems can be divided into **four** components:
1. Hardware
	- Processor (CPU)
	- Main Memory
	- I/O module
	- System Bus
2. Operating System
	Controls and coordinates the use of hardware among various applications and users
3. System and Application programs
	Define the ways in which the system resources are used to solve the computing problems of the users
4. Users
	People, Machines, Other Computers
	![[Pasted image 20250905133454.png]]
## Operating System
Exploits the hardware resources of one or more processors
Provides a set of services to system users
Manages Secondary Memory and I/O devices
## Hardware Components
- Processor
- Main Memory
- I/O Module
- System Bus
![[Pasted image 20250905133550.png]]
### Processor
- Controls the operation of the computer
- Performs the data processing functions
- Referred to as the Central Processing Unit (CPU) when there is only one processor.
### Main Memory
- Stores data and programs
- Typically Volatile; Contents of the memory are lost when the computer is shut down. (In contrast, the contents of disk memory are retained when the computer system is shut down)
- Also referred to as real memory or primary memory 
### I/O Module
Moves data between the computer and its external environment
	- Secondary memory devices (disks)
	- Communications equipment
	- Terminals
### System bus
Provides for communication among processors, main memory and I/O modules
## Computer Components: Top Level View
![[Pasted image 20250905133947.png]]
To exhcnage data with memory, the **CPU** typically makes use of two internal (to the processor) registers:
- A memory address register (**MAR**),
	- Contains specific address in memory for the next read or write
- A memory buffer register (**MBR**), 
	- Contains data to be written into memory or read
It has a further two registers to interact with I/O devices
- An I/O address register (I/OAR) specifies a particular I/O device.
- An I/O buffer register (I/OBR) is used for the exchange of data between an I/O module and the processor

A **memory module** consist of a set of locations, defined by sequentially numbered address. Each location contains a bit pattern that can be interpreted as either an instruction or data.
A **I/O module** transfers data from external devices to processor and memory, and vice versa. It contains internal buffers for temporarily storing data until they can be sent on.
## Microprocessor
- Invention that brought about desktop and handheld computing
- Contains a process on a single chip
- Fastest general purpose processors
- Multiprocessors
- Each chip (socket) contains multiple processors (cores)
## Graphic Processing Units (GPU)
- Provide efficient computation arrays of data using Single-Instruction Multiple Data (SIMD) techniques pioneered in supercomputers
- No longer used just for rendering advanced graphics
- Also used for general numerical processing
	- Physics Simulations for games
	- Computations on large spreadsheets
Digital Signal Processors (DSPs)
- Deal with streaming signals
- Used to be embedded in I/O devices like modems
- Are now becoming first-class computational devices, especially in handhelds
- Encoding/Decoding speech and video (codecs)
- Provide support for encryption and security
## System on a Chip (SoC)
- To Satisfy the requirements of handheld devices, the classic microprocessor is giving way to the SoC
- Other components of hte system, such as DSPs, and GPUs, I/O (Such as codecs and radios), and main memory, in additional to the CPUs and caches, are on the same chip
# Instruction Execution
A program consists of a set of instructions stored in memory
## Two Steps
Process reads (fetches) instructions from memory
Processor executes each instruction
### Basic Instruction Cycle
![[Pasted image 20250905135131.png]]
## Characteristics of a Hypothetical Machine
Instructions and data are 16 bit long, and memory is organized as a sequence of 16-bit words
Instructions are 4 bit $2^{4}$ Instructinos
# Interrupts
## Classes of Interrupts
### Program
	Genearted by some condition that occurs as a result of an instruction execution, such as aritmetic overflow, division by zero, attempt to oexecute an illegal machine instruction, or reference outside a user's allowed memory space
### Timer
	Generated by a time within the processor
	Used to allow OS to perform functions on a regeualr basis
### I/O
	 Generated by a I/O controller, to signal normal completion or to signal a variety of erroy
### Hardware Failure
	Generated by a failure, such as powerfailure or memory parity error

## Flow Control without and With Interrupts
![[Pasted image 20250905140255.png]]
### 1. Sequence of instructions to prepare for actual I/O operation
### 2. Actual I/O Command Execution
### 3. Sequence of Instructions to complete
## Instruction Cycles with Interrupts
![[Pasted image 20250905140530.png]]
## Simple Interrupt Processing
![[Pasted image 20250905140848.png]]
## Multiple Interrupts
if  during an interrupt while another interrupt is processed
### Two Approaches
1. Disable Interrupts while an interrupt is being processed
2. Used a priority scheme
![[Pasted image 20250905141032.png]]
![[Pasted image 20250905141056.png]]
#### Priority System
Priority goes larger more important 
Printer (2) ,Disk (4), Communications Line (5)
![[Pasted image 20250905141245.png]]
# Memory Hierarchy
Going down the memory heirarchy
- Decreasing cost per bit
- Increasing Capcity
- Increasing Access time
- Decreasing frequency of access to the memory by the processor
![[Pasted image 20250905141437.png]]k
## Trade-off
1. Access time
2. Capacity
3. Cost
![[Pasted image 20250905141418.png]]
## Principle of Locality (Temporal Locality & Spacial Locality)
• Memory references by the processor tend to cluster  
• Data is organized so that the percentage of accesses to each successively lower level is substantially less than that of the level above
### Secondary Memory
External Non-volatile (HDD,SSD)
### Cache Memory
Invisible to the OS, (Cache L2/L3)
![[Pasted image 20250905141959.png]]
## I/O techniques
- when the processor encounters and a I/O Instruction it execute using the I/O module
There is 3 techniques for I/O Operations
### Programmed I/O
The I/O module performs the requested acions then sets hte appropriate bits in teh I/O Status register
The Process periodically checks the status until its done
### Interrupt Driven I/O
I/O process starts the then the processor goes do other work
More Efficient than Programmed I/O but still requires active intervention of the process to transfer data between memory and an I/O module
### Direct Memory Access (DMA)
Transfer rate is limited by the speed with which the rpcoessor can test and service a device

Processor is tied up in maanging I/O Transfer
	- A number of instructions must be executed for each I/O transfer
Limited by speed of Main memory
Processor is only involved at the beginning and end of the transfer
More efficient than interrupt-driven or programmed I/O
# Multiprocessor and Multicore Organization
## Symmetric Multiprocessors (SMP)
two or more similar processors of comparable capabilities
Processors share access to I/O
All processors can perform the same functions
Share same bus
![[Pasted image 20250905143800.png]]
### Advantages
#### Performance 
	A system with multiple processors will yield greater perofmrance if owrk can be done in parrallel
#### Scaling
	Vendors can offer a range of products with different price and performance  characteristics
#### Availability
	The failure of a single processor does not halt the machine
#### Incremental Growth
	An additional processor can be added to enhance perfromance
## Multicore Computer
Includes L2 cache and L3 Cache (sometimes)
Each core consists of all the components of an independent processor
![[Pasted image 20250905143958.png]]
# Operating Systems
A program that controls the execution of application programs
An interface between applications and hardware
## Main objectives of an OS
- Convenience
- Efficiency
- Ability to evolve
![[Pasted image 20250905144222.png]]
## OS Services
- Program Development
- Program Execution
- Access I/O devices
- Controlled access to files
- System access
- Error detection and response
- Accounting
## Key Interfaces
### Instruction set architecture ISA
Is the boundary between hardware and software
The OS has access to additional machine language instruction that deal with managing system system resources
### Application Binary interface ABI
Defines a standard for binary portability across programs
Defines systme call interface to the OS and the hardware resources and services available in **ISA**
### Application Programming Interface API
Gives a program access to the Hardware using the ISA using HLL (High Level Languages) library calls.

## Takeaway
The OS acts as a resource manager
## OS as software
Frequently relinquished control and must depend on the processor to allow it to regain control
# Evolution of OS
A major OS will evolve overtime for a number of reasons:
- Hardware upgrades
- New types of hardware
- Fixes
- New Services
## Serial Processing
Earliest computers
- No OS
- Console display lights
- User has access to the computer inseries
### Problems
Scheduling
	Most installatinos used a hardcopy sign-up sheet ot reserve computer time	
Setup time
	Takes a while to setup the program to run
## Simple Batch Systems
Early computers were very expensive
### Monitor
Users  no longer had direct access to the processor
Job is submitted to computer operator who batches them together and a places them on an input device
program branches 
![[Pasted image 20250905144954.png]]
#### Processor point of view
Processor executes instruction from the memory containing the
monitor
Executes the instructions in the user program until it encounters an
ending or error condition
"Control is passed to a job" means that the processor is fetching and
executing instructions in a user program
"Control is returned to the monitor" means that the processor is
fetching and executing instructions from the monitor program
### Job Control Language (JCL)
A special type of programming language used to provide instructions to the monitor
 
Fortran is a Example
# Desirable Hardware Features  
## Memory protection  
While the user program is executing, it must not alter the memory area containing the monitor  
## Timer  
Prevents a job from monopolizing the system  
## Privileged Instructions  
Can only be executed by the monitor  
## Interrupts  
Gives OS more flexibility in controlling flow of user programs
# Modes of Operation 
## User Mode
- User program executes in user mode  
- Certain areas of memory are protected from user access  
- Certain instructions may not be executed

## Kernel Mode
- Monitor executes in kernel mode
- Privileged instructions may be executed
- Protected areas of memo ma be accessed
## Multiprogrammed Batch Systems
Processor is often idle
Even with automatic job sequencing
I/O devices are slow compared to processors
![[Pasted image 20250905145342.png]]
### Uniprogramming
- The processor spends a certain amount of time executing until it reaches an I/O instruction;
it must then wait until that I/O instruction concludes before proceeding
### Multiprogramming
Also known as multitasking. The act of performing more than one task at the same time. Memory is expanded to hold two or more programs and switch among all of them.
![[Pasted image 20250905145520.png]]
#### Example
![[Pasted image 20250905145541.png]]
![[Pasted image 20250905145627.png]]
![[Pasted image 20250905145636.png]]
## Time Sharing Systems
Can be used to handle multiple interactive jobs
Processor time is shared among multiple users
### Batch Multiprogramming versus Time Sharing
![[Pasted image 20250905145806.png]]

## Compatible Time-Sharing Systems (CTSS)
One of the first time-sharing operating systems
Developed at MIT by a group Project MAC at 1961 for the IBM 709
Utilized a technique known as *time slicing*
### Time Slicing
The system clock generates a interrupting at a rate of approximately one every 0.2 seconds
At each 0.2 interval the OS regains control and could assign processor to another user

To preserve the older user status for later resumption, the old user programs and data were written out to disk before the new user programs and data were read in

Old users program code and data were restored in main memory when that program was next given a turn

To minimize disk traffic, user memory was only written out when the incoming program would overwrite it.

![[Pasted image 20250905150139.png]]
```
Assume there are four interactive users with the  
following memory requirements, in words:  
JOB1 (15,000), JOB2 (20,000), JOB3 (5,000),  
JOB4 (10,000).  
Initially, the monitor loads JOB1 and transfers control  
to it (a).  
Later,the monitor decides to transfer control to JOB2.  
Because JOB2 requires more memory than JOB1,  
JOB1 must be written out first, and then JOB2 can be  
loaded (b).  
Next, JOB3 is loaded in to be run. However, because  
JOB3 is smaller than JOB2, a portion of JOB2 can  
remain in memory, reducing disk write time (c).  
Later, the monitor decides to transfer control back to  
JOB1. An additional portion of JOB2 must be written  
out when JOB1 is loaded back into memory (d).  
When JOB4 is loaded, part of JOB1 and the portion of  
JOB2 remaining in memory are retained (e).  
At this point, if either JOB1 or JOB2 is activated, only  
a partial load will be required. In this example, it is  
JOB2 that runs next. This requires that JOB4 and the  
remaining resident portion of JOB1 be written out, and  
the missing portion of JOB2 be read in (f)
```

# Major Achievements
Operating Systems are among the most complex pieces of software ever developed
The major advances in development include
### Processes
	Fundamental to the structure of operating systems
- A program in execution
- An instance of a running program
- The entity that can be assigned to, and executed on, a processor
- A unit of activity characterized by a single sequential thread of execution, a current state, and an associated set of system resources
#### Causes of errors
- Nondeterminate program Operation
	Program execution is interleaved by the procoessor when memory is shared
	
- Deadlocks
	It is possible for two or more programs to be hung up waiting for each other
	
- Improper synchronization
	A program must wait until the data are available in a buffer
	
- Failed Mutual exclusion
	More than one user or program attempts to make use of shared resource at the same time
#### Components of a Process
A process contains 3 components
1. A exectuable program
2. The associated data needed by the program 
	(variables, workspace, buffers, etc)
3. The execution context (or "process state") of t he progrma

The Execution context is essential:
- It is the internal data the OS supervise and controls
- Includes the contents of the various process registers
- Information such as the priority of the process and whether the process is waiting for the completion of a particular I/O event
### Memory management
The OS has **5** principal storage management responsibilities
Process Isolation
Automatic Allocation and Management
Support of modular programming
Protection and access control
Long-term storage

### Information protection and security
### Scheduling and resource management
### System Structure

# Developments Leading to Modern Operations Systems
## Microkernel architecture
Most operating systems until recently featured a **monolithic kernel**
### Microkernal
- Address Space management
- Interposes Communication
- Basic Scheduling
## Multithreading
Technique in which a process, executing an application, is divided into threads that can run concurrently

#### Thread
- Dispatchable unit of work
- Includes a processor context and its own data area for a stack
- Executes sequentially and is interruptible
#### Process
- A collection of one or more threads and associated system resources
- By breaking a single application into multiple threads, a programmer has greater control over the modularity of the application and the timing of application-related events
## Symmetric multiprocessing
Term that refers to a computer hardware architecture and also to the OS behavior that exploits that architecture
![[Pasted image 20250905151446.png]]
## Distributed operating systems
provides illusion of
- A single main memory space
- Single secondary memory space
- unified access facilities such as file systems
## Object-oriented design
- Leads discipline to the process adding modular extensions to a small kernel
- Enables programmers to customize an operating system without disrupting system integrity
- Eases the development of distributed tools and full blow distributed operating systems

# SMP OS Considerations
## Simultaneous concurrent processes or threads
Kernel routines need to be reentrant to allow several processors to execute the same kernel code simultaneously
## Scheduling
Any processor may perform scheduling, which complicates the task of enforcing a scheduling policy
## Synchronization
With multiple active processes having potential access to shared address spaces or shared 1/0 resources, care must be taken to provide effective synchronization
## Memory management
The reuse of physical pages is the biggest problem of concern
## Reliability and fault tolerance
The OS should provide graceful degradation in the face of processor failure
# Multicore OS Consideration
Hardware parallelism within each core processor, known as instruction
level parallelism
Potential for multiprogramming and multithreaded execution within each processor
Potential for a single application to execute in concurrent processes or threads across multiple cores

# Multicore Support
### Grand Central Dispatch (GCD)
Once a developer has identified something
that can be split off into a separate task,
GCD makes it as easy and noninvasive as
possible to actually do so
### Virtual Machine Approach
Allows one or more cores to be dedicated to a particular
process and then leave the processor alone to devote its efforts to that process

Multicore OS could then act as a hypervisor that
makes a high-level decision to allocate cores to
applications but does little in the way of resource allocation beyond that