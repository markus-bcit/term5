# Memory Management Requirements
## Relocation
Programmers typically don't know which other programs will be resident in main memory at the time of execution of their program

Active processes need to be able to be swapped in and out of main memory in order to maximize processor utilization

Specifying that a process must be placed in the same memory region when it is swapped back in would be limiting
	May need to **relocate** the process to a different area of memory
	![[Pasted image 20251003133529.png]]
## Protection
Processes need to acquire permission to reference memory locations for reading or writing purposes
Location of a program in main memory is unpredictable
Memory references generated by a process must be checked at runtime.
Mechanisms that support relocation also support protection
## Sharing
Advantageous to allow each process access to the same copy of the program rather than have their own separate copy

Memory management must allow controlled access to shared areas of memory without compromising protection

Mechanisms used to support relocation support sharing capabilities.
## Logical Organization
Memory is organized as linear.
Programs are written in modules
	Modules can be written and compiled independently
	Different Degrees of protection given to modules (read-only, execute-only)
	Sharing on a module level corresponds to the user's way of viewing the problem

Segmentation is the tool that most readily satisfies requirements
## Physical Organization
Cannot leave the programmer with the responsibility to manage memory
Memory available for a program plus its data may be insufficient
	**Overlaying** allows various modules to be assigned the same region of memory btu is time-consuming to program

Programmer does not know how much space will be available
# Memory Partitioning
![[Pasted image 20251003133918.png]]

## Fixed Partitioning
![[Pasted image 20251003134122.png]]
![[Pasted image 20251003134150.png]]

## Dynamic Partitioning
![[Pasted image 20251003134254.png]]
## Definitions
### Internal Fragmentation
- Wasted space due to the block of data loaded being smaller than the partition.
### External Fragmentation
- A situation in which there are a lot of small holes in memory.
- As time goes on, memory becomes more and more fragmented, and memory utilization declines
### Compaction
- One technique for overcoming external fragmentation is compaction
- From time to time, the OS shifts the processes so they are contiguous and all of the free memory is together in one block.
- Time-consuming and wastes CPU time.

# Placement Algorithms
## Best-fit
Chooses the block that is closest in size to the request
## First-fit
Begins to scan memory from the beginning and chooses the first a available block that is large enough.
## Next-fit
Begins to scan memory from the location of the last placement and chooses the next available block that is large enough.

![[Pasted image 20251003134959.png]]
![[Pasted image 20251003135048.png]]
![[Pasted image 20251003135102.png]]
## Relocation
When the fixed partition scheme is used, we can expect a process will always be assigned to the same partition
- Whichever partition is selected when a new process is loaded will always be used to swap that process back into memory after it has been swapped out
- In that case, a simple relocating loader can be used
- When the process is first loaded , all relative memory reference s in the code are replaced by absolute main memory addresses, determined by the base address Of the loaded process

In the case of equal-size partitions and in the case of a single process queue for unequal-size partitions, a process may occupy different partitions during the course of its life
- when a process image is first created, it is loaded into some partition in main memory; Later, the process and be swapped out
- When it is subsequently swapped back in, it may be assigned to a different partition that than the last time
- The same is true for dynamic partitioning 

When compaction is used, processes are shifted while they are in main memory
- Thus, the locations referenced by a process are not fixed
- They will change each time a process is swapped in or shifted.
## Addresses
**Logical** - Reference to a memory location independent of the current assignment of data to memory
**Relative**- A particular example of logical address in which the address is expressed as location relative to some known point
**Physical or Absolute** - Actual location in main memory
![[Pasted image 20251003140221.png]]
# Paging
- Partition memory into equal fixed-size chunks that are relatively small
- Process is also divided into small fixed-size chunks of the same size.
## Terms:
**Frame** - A fixed-length block of main memory
**Page** - A fixed-length block of data that resides in secondary memory (such as a disk). A page of data may temporarily be copied into a frame of main memory.
**Segment** - A variable-length block of data that resides in secondary memory.an available region of main memory (segmentation) or the segment may be divided into pages, which can be individually copied into main memory (combined segmentation and paging)
![[Pasted image 20251003140707.png]]
## Page Table
- Maintained by operating system for each process
- Contains the frame location for each page in the process
- Processor must know how to access for the current process
- Used by processor to produce a physical address.
![[Pasted image 20251003141110.png]]
### Logical Memory
![[Pasted image 20251003141135.png]]
![[Pasted image 20251003141135.png]]
# Segmentation
- A program can be subdivided into segments:
	- May Very in length
	- There is a maximum length
- Addressing consists of two parts:
	- Segment number
	- An offset
- Similar to dynamic partitioning
- Eliminates internal fragmentation
- Usually visible
- Provided as convenience for organizing programs and data
- Typically the programmer will assign programs and data to different segments
- For purposes of modular programming the program or data may be further broken down into multiple segments
	- The principal inconvenience of this service is that programmer must be aware of the maximum segment size limitation.
## Address Translation
Another consequence of unequal size segments is that there is no simple relationship between logical addresses and physical addresses

The following steps are needed for address translation

1. Extract the segment number as the left more n bits of the logical address 
2. Use the segment number as index into the process segment table to find the starting physical address of the segment
3. Compare the offset, expressed in the rightmost m bits, to the length of the segment. If the offset is greater or equal to the length, the address is invalid
4. The desired physical address is the sum of the starting physical address of the segment plus the offset
![[Pasted image 20251003141700.png]]